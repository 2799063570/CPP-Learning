# 总结

STL和数据结构也已经学完了，但是leetcode刷题效果并不好。感觉并没有掌握，所以总结回顾一下，STL模板库。

首先最先学到的**线性结构**，最经典就是vector，在堆上申请一块连续的内存，提供一些相应的增删改查的数据操作方法。同时最重要的一点是扩容机制，根据size大小，在堆上申请一块更大的内存，将原来的数据迁移到新的内容上，将原内存释放。因为vector的数据存储在空间中存放是连续的，那么肯定是支持随机访问的。
但同时也带来了一个问题，对于数据的插入和删除，势必会对该元素之后的元素进行迁移，运算量是比较大。
**string是vector的一种特殊情况**(char类型vector，最后一位字符为'\0')，同时也增加了比如说字符串比较、替换、子串等方法。

vecotr在首端插入元素效率是很低的，因为首端每插入一个元素，势必让其后面的n个元素，向后移动一个位置。为此，引入一种新的容器，**双端队列deque**，该容器是一种多端连续的数据类型。逻辑结构同STL一样，但物理结构有很大的差别，deque 容器的底层实现通常是由多个固定大小的内存块（称为“缓冲区”或“块”）组成。deque可以想象为一个存放了很多固定大小内存对应地址的数组。对应的操作函数和vector基本相同。

链表相对于vector这种顺序表来说，有很大的差异。

- 数据的存放是不连续的，由一个个节点组成。所以遍历、查找起来还是相对于vector麻烦很多，不支持随机访问。
- 同时带来顺序是比较灵活的，插入、删除元素只需要对相应的节点进行操作，因此适合于频繁的插入删除。

STL中链表的实现容器为**list，循环双端链表**，一种双向链表，每个节点分别指向前一个节点和后一个节点。

基于上述容器的实现，就出现了**栈stack和队列queue**两种容器，分别对应先入后出和先入先出。使用vector、deque实现栈很容易理解，就是分别只对尾端进行插入和删除操作。而队列则是对头端进行删除，尾端进行插入操作。

下面是树形结构，最经典的就是基于二叉搜索树的set和map容器。二叉搜索树的特点就是左子树节点值小于根节点值，右子树节点值大于根节点值。因此二叉搜索树的中序遍历结果是一个单调递增的序列，因此**set、map容器的数据存储是有序**的。需要注意的是，两种容器会根据数据的大小进行自动排序，所以针对于自定义类型，需要重载小于运算符<，告诉编译器如何比较两个对象的大小关系。同时呢，set和map是不允许重复存储的，因此有对应的**multiset和multimap容器**，允许重复存储。

模拟树型逻辑（根节点大于相邻的两个子节点），但实际物理结构为vector实现的是线性模拟树--**priority_queue, 即堆结构**。堆结构分为大根堆和小根堆，分别对应根节点大于或小于子节点。堆结构的特点是可以在O(logn)时间复杂度内完成插入和删除操作，同时可以在O(1)时间复杂度内获取最大值或最小值。因此优先队列适合用于需要频繁获取最大值或最小值的场景，比如任务调度、图的最短路径算法等。

最后是哈希表结构**unordered_set和unordered_map**。哈希表通过哈希函数将键映射到桶ID，从而实现快速的数据存取。哈希表的平均时间复杂度为O(1)，但在最坏情况下可能退化为O(n)。很多语言都有哈希表的实现，不同的是处理哈希冲突(多个键值的哈希值是相同的)的方法。STL中的unordered_set和unordered_map通过链表法解决哈希冲突，即每个桶存放一个链表（链表的头、尾节点地址），链表中存放所有映射到该桶的元素。