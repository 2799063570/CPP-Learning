# 力扣难题积累

## 2762. 不间断子数组

[https://leetcode.cn/problems/continuous-subarrays/description/]
题目描述：一个整数数组nums，对其进行切片得到子数组，如果子数组满足如下条件，那么他就是不间断的：i，i+1，..., j 表示子数组中的下标。对于所有满足 i <= i1, i2 <= j 的下标对，都有`0 <= |nums[i1] - nums[i2]| <= 2` 。（即子数组中任意两个元素的差值不能大于2）
请你返回**不间断**子数组的总数目。

例如：输入nums=[5, 2, 1, 2]
那么[5]肯定是不间断的；[5, 2] 差值超过2，间断；[2, 1]差值为1，不间断；[2, 1, 2]，不间断。

需要注意的是`1 <= nums.length <= 10^5`, `1 <= nums[i] <= 10^9`，注意时间复杂度

```cpp
long long continuousSubarrays(vector<int>& nums) {
    int min = 99, max = -99;
    long long cnt = 0;
    for (int i = 1, size = nums.size(); i <= size; i++)
    {
        for (int j = 0; j+i <= size; j++)
        {   
            min = nums[j], max = nums[j];            
            for (int k = j; k < j+i; k++)
            {
                if (nums[k] < min) min = nums[k];
                else if (nums[k] > max) max = nums[k];
                if (max - min > 2) break;
            }
            if (max - min <= 2) ++cnt;
        }
    }
    return cnt;
}
```

起始想到的方法是这种，显然时间复杂度很高(套用三层循环n^3)，而nums.length可达到10^5，显然时间过高的。若想解决问题，最好使用时间复杂度为o(n)的。

```cpp
long long continuousSubarrays(vector<int>& nums) {
    multiset<int> mst;
    int i = 0, j = -1;  // j 左索引 i 右索引
    int size = nums.size();
    long long ans = 0;
    while(j++ < size-1)
    {
        mst.insert(nums[j]);
        int min = *mst.begin();
        int max = *mst.rbegin();
        while (max - min > 2)   // 当不满足子数组条件
        {
            multiset<int>::iterator iter = mst.find(nums[i]);   // 找到右索引的元素
            mst.erase(iter);
            min = *mst.begin();
            max = *mst.rbegin();
            i++;
        }
        ans += j - i + 1;
    }
    return ans;
}
```

采用的是基于集合的动态窗口法，会有两个索引指定左右指针，当窗口中的元素不满足子数组连续要求的时候，会循环的左指针移动直到窗口中的元素满足要求，同时右指针也会不断的移动直到右边界。
值得注意的是采用的是自动排序且可存在重复元素的multiset数据类型，`multiset<int>::iterator iter = mst.find(nums[i]);`对元素的删除，删除的是左指针在原数组上对应的元素。

## 3092. 最高频率的 ID

[https://leetcode.cn/problems/most-frequent-ids/description/]
题目描述: 你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 n 的整数数组 nums 和 freq ，nums 中每一个元素表示一个 ID ，对应的 freq 中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。
如：freq中元素的正负对应增删，增加或者删除freq[i]个nums[i]元素。返回的是出现次数最多元素的次数，例如输入：nums = [2,3,2,1], freq = [3,2,-3,1]，输出：[3,3,2,2]。

首先我的想法是采用数组来记录元素的出现次数，集合set来记录出现了多少个元素。因此需要两个循环，分别遍历nums\freq数组，套用遍历eles(set集合)中的元素。因此时间复杂度为o(n^2)，题目中`1 <= nums.length == freq.length <= 105`，显然时间上不符合要求。

```cpp
vector<long long> mostFrequentIDs(vector<int>& nums, vector<int>& freq) {
    vector<long long> ret;
    set<int> eles;      // 记录出现的元素
    int cnt[100001];    // 记录元素的出现个数
    memset(cnt, 0, 100001);

    for (int i = 0, size = nums.size(); i<size; i++)
    {
        eles.insert(nums[i]);
        cnt[nums[i]] += freq[i];
        int max = 0;
        for(const auto& ite : eles)
        {
            if (cnt[ite] > max) max = cnt[ite];
        } 
        ret.push_back(max);
    }
    return ret;
}
```

```cpp
vector<long long> mostFrequentIDs(vector<int>& nums, vector<int>& freq) {
    vector<long long> ret(nums.size(), 0);
    multiset<long long> cnt_set;
    multiset<long long>:: iterator iter;
    long long cnt[100001];
    memset(cnt, 0, 100001);

    for (int i = 0, size = nums.size(); i<size; i++)
    {
        int n = nums[i];
        long long& n_num = cnt[n];
        iter = cnt_set.find(n_num);
        if (iter != cnt_set.end())  // 找到了
        {
            cnt_set.erase(iter);// 对新元素的个数
        }
        n_num += freq[i];
        cnt_set.insert(n_num);
        ret[i] = *cnt_set.rbegin();
    }
    return ret;
}
```

直接用mutilset来存储次数，直接省去了遍历的步骤。时间复杂度更低

## 264. 丑数 II

[https://leetcode.cn/problems/ugly-number-ii/description/]
题目描述: 给你一个整数 n ，请你找出并返回第 n 个 丑数 。丑数 就是只包含质因数 2、3 和/或 5 的正整数。

试想一下，如果逐个的遍历的话，会有很多数并不是丑数，且每个数还需要进行质因数的分解，时间复杂度会很高。借助于优先队列，我们将最小的丑数先出队，然后将其乘以2、3、5，再入队。这样就可以保证出队的数都是丑数，且是有序的。
同时为了避免重复计数，通过一个变量来记录之前出队的丑数，当出队的数与之前出队的数相等时，循环出队，直到出队的数与之前出队的数不相等。

```cpp
#define type1 long long
int nthUglyNumber(int n) {
    priority_queue<type1, vector<type1>, greater<type1>> q;
    q.push(1);
    type1 pre = -1;
    while(n--)
    {
        type1 val = q.top();
        q.pop();
        while(val == pre)
        {
            val = q.top();
            q.pop();
        }
        pre = val;
        q.push(val * 2);
        q.push(val * 3);
        q.push(val * 5);
    }
    return pre;
}
```
