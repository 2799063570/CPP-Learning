# 力扣难题积累

## 2762. 不间断子数组

[https://leetcode.cn/problems/continuous-subarrays/description/]
题目描述：一个整数数组nums，对其进行切片得到子数组，如果子数组满足如下条件，那么他就是不间断的：i，i+1，..., j 表示子数组中的下标。对于所有满足 i <= i1, i2 <= j 的下标对，都有`0 <= |nums[i1] - nums[i2]| <= 2` 。（即子数组中任意两个元素的差值不能大于2）
请你返回**不间断**子数组的总数目。

例如：输入nums=[5, 2, 1, 2]
那么[5]肯定是不间断的；[5, 2] 差值超过2，间断；[2, 1]差值为1，不间断；[2, 1, 2]，不间断。

需要注意的是`1 <= nums.length <= 10^5`, `1 <= nums[i] <= 10^9`，注意时间复杂度

```cpp
long long continuousSubarrays(vector<int>& nums) {
    int min = 99, max = -99;
    long long cnt = 0;
    for (int i = 1, size = nums.size(); i <= size; i++)
    {
        for (int j = 0; j+i <= size; j++)
        {   
            min = nums[j], max = nums[j];            
            for (int k = j; k < j+i; k++)
            {
                if (nums[k] < min) min = nums[k];
                else if (nums[k] > max) max = nums[k];
                if (max - min > 2) break;
            }
            if (max - min <= 2) ++cnt;
        }
    }
    return cnt;
}
```

起始想到的方法是这种，显然时间复杂度很高(套用三层循环n^3)，而nums.length可达到10^5，显然时间过高的。若想解决问题，最好使用时间复杂度为o(n)的。

```cpp
long long continuousSubarrays(vector<int>& nums) {
    multiset<int> mst;
    int i = 0, j = -1;  // j 左索引 i 右索引
    int size = nums.size();
    long long ans = 0;
    while(j++ < size-1)
    {
        mst.insert(nums[j]);
        int min = *mst.begin();
        int max = *mst.rbegin();
        while (max - min > 2)   // 当不满足子数组条件
        {
            multiset<int>::iterator iter = mst.find(nums[i]);   // 找到右索引的元素
            mst.erase(iter);
            min = *mst.begin();
            max = *mst.rbegin();
            i++;
        }
        ans += j - i + 1;
    }
    return ans;
}
```

采用的是基于集合的动态窗口法，会有两个索引指定左右指针，当窗口中的元素不满足子数组连续要求的时候，会循环的左指针移动直到窗口中的元素满足要求，同时右指针也会不断的移动直到右边界。
值得注意的是采用的是自动排序且可存在重复元素的multiset数据类型，`multiset<int>::iterator iter = mst.find(nums[i]);`对元素的删除，删除的是左指针在原数组上对应的元素。

## 3092. 最高频率的 ID

[https://leetcode.cn/problems/most-frequent-ids/description/]
题目描述: 你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 n 的整数数组 nums 和 freq ，nums 中每一个元素表示一个 ID ，对应的 freq 中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。
如：freq中元素的正负对应增删，增加或者删除freq[i]个nums[i]元素。返回的是出现次数最多元素的次数，例如输入：nums = [2,3,2,1], freq = [3,2,-3,1]，输出：[3,3,2,2]。

首先我的想法是采用数组来记录元素的出现次数，集合set来记录出现了多少个元素。因此需要两个循环，分别遍历nums\freq数组，套用遍历eles(set集合)中的元素。因此时间复杂度为o(n^2)，题目中`1 <= nums.length == freq.length <= 105`，显然时间上不符合要求。

```cpp
vector<long long> mostFrequentIDs(vector<int>& nums, vector<int>& freq) {
    vector<long long> ret;
    set<int> eles;      // 记录出现的元素
    int cnt[100001];    // 记录元素的出现个数
    memset(cnt, 0, 100001);

    for (int i = 0, size = nums.size(); i<size; i++)
    {
        eles.insert(nums[i]);
        cnt[nums[i]] += freq[i];
        int max = 0;
        for(const auto& ite : eles)
        {
            if (cnt[ite] > max) max = cnt[ite];
        } 
        ret.push_back(max);
    }
    return ret;
}
```

```cpp
vector<long long> mostFrequentIDs(vector<int>& nums, vector<int>& freq) {
    vector<long long> ret(nums.size(), 0);
    multiset<long long> cnt_set;
    multiset<long long>:: iterator iter;
    long long cnt[100001];
    memset(cnt, 0, 100001);

    for (int i = 0, size = nums.size(); i<size; i++)
    {
        int n = nums[i];
        long long& n_num = cnt[n];
        iter = cnt_set.find(n_num);
        if (iter != cnt_set.end())  // 找到了
        {
            cnt_set.erase(iter);// 对新元素的个数
        }
        n_num += freq[i];
        cnt_set.insert(n_num);
        ret[i] = *cnt_set.rbegin();
    }
    return ret;
}
```

直接用mutilset来存储次数，直接省去了遍历的步骤。时间复杂度更低

## 264. 丑数 II

[https://leetcode.cn/problems/ugly-number-ii/description/]
题目描述: 给你一个整数 n ，请你找出并返回第 n 个 丑数 。丑数 就是只包含质因数 2、3 和/或 5 的正整数。

试想一下，如果逐个的遍历的话，会有很多数并不是丑数，且每个数还需要进行质因数的分解，时间复杂度会很高。借助于优先队列，我们将最小的丑数先出队，然后将其乘以2、3、5，再入队。这样就可以保证出队的数都是丑数，且是有序的。
同时为了避免重复计数，通过一个变量来记录之前出队的丑数，当出队的数与之前出队的数相等时，循环出队，直到出队的数与之前出队的数不相等。

```cpp
#define type1 long long
int nthUglyNumber(int n) {
    priority_queue<type1, vector<type1>, greater<type1>> q;
    q.push(1);
    type1 pre = -1;
    while(n--)
    {
        type1 val = q.top();
        q.pop();
        while(val == pre)
        {
            val = q.top();
            q.pop();
        }
        pre = val;
        q.push(val * 2);
        q.push(val * 3);
        q.push(val * 5);
    }
    return pre;
}
```

## 四数相加 II

给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

- 0 <= i, j, k, l < n
- nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0

输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
两个元组如下：

1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0

```cpp
int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
     int cnt = 0;
     unordered_map<int, int> m;
     for (int i = 0, size = nums1.size(); i<size; i++)
     {
         for (int j = 0; j<size; j++)
         {
             int num = nums1[i] + nums2[j];
             if (m.find(num) == m.end()) m[num] = 1;
             else m[num]++;
         }
     }
     for (int i = 0, size = nums1.size(); i<size; i++)
     {
         for (int j = 0; j<size; j++)
         {
             int num = nums3[i] + nums4[j];
             unordered_map<int, int>::iterator it = m.find(-num);
             if (it != m.end()) cnt += it->second;
         }
     }
     return cnt;
   }
```

解题方法如上，nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
可以化简为 nums1[i] + nums2[j] == -(nums3[k] + nums4[l]) 
可以先枚举出所有num1和num2数组中的元素之和，然后在枚举出所有num3和num4中元素之和，将和放置到哈希表中，和为键值，值为数量。则只要将num3+num4枚举的结果的相反数依次在哈希表中查找，经过不断的循环即可。

## 560. 和为 K 的子数组

给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数。子数组是数组中元素的连续非空序列。
例如：输入：nums = [1,1,1], k = 2 输出：2

最简单的方法就是暴力枚举，枚举出所有的子数组，和k值进行比较

```cpp
int cnt = 0;
for (int i = 0, size = nums.size(); i<size; i++)
{
   int sum = 0;
   for (int j = i; j<size; j++)
   {
       sum += nums[j];
       if (sum == k)
       {
           cnt++;
       }
   }
}
return cnt;
```

力扣官方题解
链接：https://leetcode.cn/problems/subarray-sum-equals-k/solutions/238572/he-wei-kde-zi-shu-zu-by-leetcode-solution/

则该方法的时间复杂度为O(n^2) 对于非常长的数组方法失效
下面介绍一种**前缀和 + 哈希表优化**的方法
在暴力枚举的方法中，每个i都要枚举很多的j
我们定义pre[j]为0-j元素之和，那么pre[j+1] = pre[j] + nums[j+1],pre[j] = pre[j-1] + nums[j]。
那么[j,...,i]所组成的子数组可以表示为pre[i] - pre[j-1]，题目要求满足子数组等于k，即pre[i] - pre[j-1] = k; pre[j-1] = pre[i] + k;
所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1) 时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。
需要注意的是，从左往右边更新边计算的时候已经保证了mp[pre[i]−k] 里记录的 pre[j] 的下标范围是 0≤j≤i 。同时，由于pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用 pre 变量来记录 pre[i−1] 的答案即可。

```cpp
unordered_map<int, int> cnt;
int ans = 0;
int pre = 0;
cnt[pre]++;
for (int i = 0, size = nums.size(); i<size; i++)
{
    pre = pre + nums[i];
    ans += cnt[pre - k];
    cnt[pre]++;
}
return ans;
```